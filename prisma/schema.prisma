generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model SearchLog {
  id          String   @id @default(uuid())
  timestamp   DateTime @default(now())
  searchQuery String
}

model Episode {
  id                             String         @id @default(uuid())
  episodeAuthor                  String         @db.VarChar(500)
  episodeTitle                   String         @db.VarChar(500)
  episodeImage                   String         @db.VarChar(500)
  episodeLinkToEpisode           String         @db.VarChar(500)
  episodeAuthors                 String         @db.VarChar(500)
  episodeSummary                 String         @db.Text
  episodeEnclosure               String         @db.VarChar(500)
  episodeLanguage                String         @db.VarChar(500)
  podcastRssFeed                 String         @db.VarChar(500)
  podcastAuthor                  String         @db.VarChar(500)
  podcastSummary                 String         @db.Text
  podcastLanguage                String         @db.VarChar(500)
  podcastTitle                   String         @db.VarChar(500)
  podcastGuid                    String         @db.VarChar(500)
  podcastImage                   String         @db.VarChar(500)
  episodeGuid                    String         @unique @db.VarChar(500)
  episodePublished               DateTime
  episodeDuration                Int
  isTranscribed                  Boolean        @default(false)
  beingTranscribed               Boolean        @default(false)
  causedError                    Boolean        @default(false)
  updatedAt                      DateTime?      @updatedAt
  addedDate                      DateTime       @default(now())
  reAlignedWithBigModel          Boolean        @default(false)
  youtubeVideoLink               String?
  deviationTime                  Float?
  highestSimilarityVideo         Float?
  isRead                         Boolean?       @default(false)
  indexed                        Boolean        @default(false)
  Podcast_belongsToPodcast       Podcast        @relation("Podcast_belongsToPodcast", fields: [podcastGuid], references: [podcastGuid], onDelete: Cascade)
  Segment                        Segment[]
  Transcription_hasTranscription Transcription? @relation("Episode_belongsToEpisodeGuid")

  @@index([podcastGuid], map: "Episode_podcastGuid_fkey")
}

model Podcast {
  id                              String          @id @default(uuid())
  url                             String          @db.VarChar(500)
  title                           String          @db.VarChar(500)
  link                            String          @db.VarChar(500)
  contentType                     String          @db.VarChar(500)
  originalUrl                     String          @db.VarChar(500)
  itunesAuthor                    String          @db.VarChar(500)
  itunesOwnerName                 String          @db.VarChar(500)
  itunesType                      String          @db.VarChar(500)
  generator                       String          @db.VarChar(500)
  language                        String          @db.VarChar(500)
  chash                           String          @db.VarChar(500)
  host                            String          @db.VarChar(500)
  category1                       String          @db.VarChar(500)
  category2                       String          @db.VarChar(500)
  category3                       String          @db.VarChar(500)
  category4                       String          @db.VarChar(500)
  category5                       String          @db.VarChar(500)
  category6                       String          @db.VarChar(500)
  category7                       String          @db.VarChar(500)
  category8                       String          @db.VarChar(500)
  category9                       String          @db.VarChar(500)
  category10                      String          @db.VarChar(500)
  imageUrl                        String          @db.VarChar(500)
  newestEnclosureUrl              String          @db.VarChar(500)
  description                     String          @db.Text
  podcastGuid                     String          @unique
  explicit                        Int
  dead                            Int
  itunesId                        Int
  episodeCount                    Int
  lastHttpStatus                  Int
  popularityScore                 Int
  newestEnclosureDuration         Int
  priority                        Int
  updateFrequency                 Int
  createdOn                       DateTime
  youtubeChannel                  String?
  indexed                         Boolean         @default(false)
  Episode_hasEpisodes             Episode[]       @relation("Podcast_belongsToPodcast")
  Segment_hasSegments             Segment[]       @relation("Podcast_belongsToPodcastGuid")
  Transcription_hasTranscriptions Transcription[] @relation("Podcast_belongsToPodcastGuid")
}

model Segment {
  id                                  String        @id @default(uuid())
  start                               Float
  end                                 Float
  language                            String        @db.VarChar(500)
  belongsToPodcastGuid                String        @db.VarChar(500)
  belongsToEpisodeGuid                String        @db.VarChar(500)
  belongsToTranscriptId               String        @db.VarChar(500)
  text                                String        @db.VarChar(500)
  indexed                             Boolean       @default(false)
  segmentWordEntries                  Json?
  Episode                             Episode       @relation(fields: [belongsToEpisodeGuid], references: [episodeGuid], onDelete: Cascade)
  Podcast_belongsToPodcastGuid        Podcast       @relation("Podcast_belongsToPodcastGuid", fields: [belongsToPodcastGuid], references: [podcastGuid], onDelete: Cascade)
  Transcription_belongsToTranscriptId Transcription @relation("Transcription_belongsToTranscriptId", fields: [belongsToTranscriptId], references: [id], onDelete: Cascade)

  @@unique([belongsToEpisodeGuid, start, end])
  @@index([belongsToPodcastGuid], map: "Segment_belongsToPodcastGuid_fkey")
  @@index([belongsToTranscriptId], map: "Segment_belongsToTranscriptId_fkey")
}

model Transcription {
  id                           String    @id @default(uuid())
  language                     String    @db.VarChar(500)
  belongsToPodcastGuid         String    @db.VarChar(500)
  belongsToEpisodeGuid         String    @unique @db.VarChar(500)
  transcription                String    @db.MediumText
  indexed                      Boolean   @default(false)
  Segment_hasSegments          Segment[] @relation("Transcription_belongsToTranscriptId")
  Episode_belongsToEpisodeGuid Episode   @relation("Episode_belongsToEpisodeGuid", fields: [belongsToEpisodeGuid], references: [episodeGuid], onDelete: Cascade)
  Podcast_belongsToPodcastGuid Podcast   @relation("Podcast_belongsToPodcastGuid", fields: [belongsToPodcastGuid], references: [podcastGuid], onDelete: Cascade)

  @@index([belongsToPodcastGuid], map: "Transcription_belongsToPodcastGuid_fkey")
}
